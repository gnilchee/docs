{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Just a place for me to keep notes. I am just getting started on this. More to come soon. Getting Started See Kubernetes for some notes on Kubernetes RBAC.","title":"Welcome"},{"location":"#welcome","text":"Just a place for me to keep notes. I am just getting started on this. More to come soon.","title":"Welcome"},{"location":"#getting-started","text":"See Kubernetes for some notes on Kubernetes RBAC.","title":"Getting Started"},{"location":"kubernetes/rbac/","text":"Role Based Access Control (RBAC) Assumptions You are familiar with Kubernetes You are familiar with kubectl Many of the examples in this doc assume you are using Microk8s but can be easily modified to work with vanilla kubectl Helpful Links RBAC Overview (Docs) API Concepts (Docs) Configuring Service Accounts (Docs) Reference Documentation accessing Service Account API Tokens (Docs) Restrict User to one Namespace (Blog) Launch A Kubernetes Cluster Quickly (Project) Installing Snap (Docs) Helpful Starter Config Source from Microk8s (Github) Before You Begin Be aware I recommended that you perform all RBAC examples within a throwaway Kubernetes cluster until you become more familiar with it. I recommend using Microk8s to spin up a dev cluster fast. Show me how to setup a kubernetes cluster with RBAC and Microk8s Install latest stable version of Kubernetes via Snap snap install microk8s --classic Install specified channel of Kubernetes via Snap snap install microk8s --classic --channel=1.15/stable How to list available channels of Microk8s in Snap snap info microk8s Enable RBAC in Microk8s microk8s.enable rbac See Microk8s Docs for more information. The Basics There are 4 main components to implementing RBAC in Kubernetes: Role - Define a set of permissions to resources within a single namespace. ClusterRole - Grant similar permissions to Role but scoped to the cluster (i.e. Nodes), across multiple namespaces or against non-resource endpoints. RoleBinding - Grant permissions defined in a role to a user or group of users (or service accounts) within a namespace. ClusterRoleBinding - Same as RoleBinding but cluster-wide. Examples Lets perform some practical examples leveraging the above components. Create a Service Account and Namespace cat <<EOF | microk8s.kubectl apply -f - apiVersion: v1 kind: Namespace metadata: name: dev --- apiVersion: v1 kind: ServiceAccount metadata: name: dev-pod-user namespace: dev EOF Note Service Accounts are Namespaced which means a service account must be created for every namespace you plan to leverage them. Although, you can grant cluster permissions to a Service Account it cannot be used outside the namespace it was created in. We will validate this further down. Role Role definition Let's define a Role called full-access-to-pods which we will grant access to the pods resource in the core API group ( \"\" ) allowing all ( '*' ) API verbs. Basically granting full access to the /api/v1/pods Kubernetes API within the dev namespace. kind : Role apiVersion : rbac.authorization.k8s.io/v1 metadata : name : full-access-to-pods namespace : dev rules : - apiGroups : - \"\" resources : - pods verbs : - '*' How do I find any of the following on an API resource? If the resource is Namespaced (scoped to a namespace) What API Group it's apart of What Verbs are allowed Resource names, shortnames, api groups, if the resource is namespaced (true/false), kind and allowed verbs are all available via the microk8s.kubectl api-resources -o wide command. Show me how to obtain API Resource details via kubectl $ microk8s.kubectl api-resources -o wide NAME SHORTNAMES APIGROUP NAMESPACED KIND VERBS bindings true Binding [create] componentstatuses cs false ComponentStatus [get list] configmaps cm true ConfigMap [create delete deletecollection get list patch update watch] endpoints ep true Endpoints [create delete deletecollection get list patch update watch] events ev true Event [create delete deletecollection get list patch update watch] limitranges limits true LimitRange [create delete deletecollection get list patch update watch] namespaces ns false Namespace [create delete get list patch update watch] nodes no false Node [create delete deletecollection get list patch update watch] persistentvolumeclaims pvc true PersistentVolumeClaim [create delete deletecollection get list patch update watch] persistentvolumes pv false PersistentVolume [create delete deletecollection get list patch update watch] pods po true Pod [create delete deletecollection get list patch update watch] podtemplates true PodTemplate [create delete deletecollection get list patch update watch] [snipped] horizontalpodautoscalers hpa autoscaling true HorizontalPodAutoscaler [create delete deletecollection get list patch update watch] cronjobs cj batch true CronJob [create delete deletecollection get list patch update watch] jobs batch true Job [create delete deletecollection get list patch update watch] certificatesigningrequests csr certificates.k8s.io false CertificateSigningRequest [create delete deletecollection get list patch update watch] leases coordination.k8s.io true Lease [create delete deletecollection get list patch update watch] endpointslices discovery.k8s.io true EndpointSlice [create delete deletecollection get list patch update watch] events ev events.k8s.io true Event [create delete deletecollection get list patch update watch] ingresses ing extensions true Ingress [create delete deletecollection get list patch update watch] ingresses ing networking.k8s.io true Ingress [create delete deletecollection get list patch update watch] networkpolicies netpol networking.k8s.io true NetworkPolicy [create delete deletecollection get list patch update watch] runtimeclasses node.k8s.io false RuntimeClass [create delete deletecollection get list patch update watch] poddisruptionbudgets pdb policy true PodDisruptionBudget [create delete deletecollection get list patch update watch] podsecuritypolicies psp policy false PodSecurityPolicy [create delete deletecollection get list patch update watch] clusterrolebindings rbac.authorization.k8s.io false ClusterRoleBinding [create delete deletecollection get list patch update watch] [snipped] Now Lets apply the Role cat <<EOF | microk8s.kubectl apply -f - kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: full-access-to-pods namespace: dev rules: - apiGroups: - \"\" resources: - pods verbs: - '*' EOF RoleBinding Now that we created a new namespace called dev , a service account called dev-pod-user and a role called full-access-to-pods lets associate them together with a RoleBinding. RoleBinding definition Let's define a RoleBinding called full-access-to-pods-role-binding which we will grant service account dev-pod-user access to the full-access-to-pods role. apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : full-access-to-pods-role-binding namespace : dev roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : full-access-to-pods subjects : - kind : ServiceAccount name : dev-pod-user See Binding Documentation for more information. Now Lets apply the RoleBinding cat <<EOF | microk8s.kubectl apply -f - apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: full-access-to-pods-role-binding namespace: dev roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: full-access-to-pods subjects: - kind: ServiceAccount name: dev-pod-user EOF Tldr In order to create a service account you need to target an existing namespace or create a new one. A role can be created without a specific service account in mind but also need to target an existing namespace or create a new one. When creating a RoleBinding you will need to target a namespace, an existing role (roleRef) in that namespace and a user, group, or service account (subject). Using our new role TODO","title":"RBAC"},{"location":"kubernetes/rbac/#role-based-access-control-rbac","text":"","title":"Role Based Access Control (RBAC)"},{"location":"kubernetes/rbac/#assumptions","text":"You are familiar with Kubernetes You are familiar with kubectl Many of the examples in this doc assume you are using Microk8s but can be easily modified to work with vanilla kubectl","title":"Assumptions"},{"location":"kubernetes/rbac/#helpful-links","text":"RBAC Overview (Docs) API Concepts (Docs) Configuring Service Accounts (Docs) Reference Documentation accessing Service Account API Tokens (Docs) Restrict User to one Namespace (Blog) Launch A Kubernetes Cluster Quickly (Project) Installing Snap (Docs) Helpful Starter Config Source from Microk8s (Github)","title":"Helpful Links"},{"location":"kubernetes/rbac/#before-you-begin","text":"Be aware I recommended that you perform all RBAC examples within a throwaway Kubernetes cluster until you become more familiar with it. I recommend using Microk8s to spin up a dev cluster fast. Show me how to setup a kubernetes cluster with RBAC and Microk8s","title":"Before You Begin"},{"location":"kubernetes/rbac/#install-latest-stable-version-of-kubernetes-via-snap","text":"snap install microk8s --classic","title":"Install latest stable version of Kubernetes via Snap"},{"location":"kubernetes/rbac/#install-specified-channel-of-kubernetes-via-snap","text":"snap install microk8s --classic --channel=1.15/stable","title":"Install specified channel of Kubernetes via Snap"},{"location":"kubernetes/rbac/#how-to-list-available-channels-of-microk8s-in-snap","text":"snap info microk8s","title":"How to list available channels of Microk8s in Snap"},{"location":"kubernetes/rbac/#enable-rbac-in-microk8s","text":"microk8s.enable rbac See Microk8s Docs for more information.","title":"Enable RBAC in Microk8s"},{"location":"kubernetes/rbac/#the-basics","text":"There are 4 main components to implementing RBAC in Kubernetes: Role - Define a set of permissions to resources within a single namespace. ClusterRole - Grant similar permissions to Role but scoped to the cluster (i.e. Nodes), across multiple namespaces or against non-resource endpoints. RoleBinding - Grant permissions defined in a role to a user or group of users (or service accounts) within a namespace. ClusterRoleBinding - Same as RoleBinding but cluster-wide.","title":"The Basics"},{"location":"kubernetes/rbac/#examples","text":"Lets perform some practical examples leveraging the above components.","title":"Examples"},{"location":"kubernetes/rbac/#create-a-service-account-and-namespace","text":"cat <<EOF | microk8s.kubectl apply -f - apiVersion: v1 kind: Namespace metadata: name: dev --- apiVersion: v1 kind: ServiceAccount metadata: name: dev-pod-user namespace: dev EOF Note Service Accounts are Namespaced which means a service account must be created for every namespace you plan to leverage them. Although, you can grant cluster permissions to a Service Account it cannot be used outside the namespace it was created in. We will validate this further down.","title":"Create a Service Account and Namespace"},{"location":"kubernetes/rbac/#role","text":"Role definition Let's define a Role called full-access-to-pods which we will grant access to the pods resource in the core API group ( \"\" ) allowing all ( '*' ) API verbs. Basically granting full access to the /api/v1/pods Kubernetes API within the dev namespace. kind : Role apiVersion : rbac.authorization.k8s.io/v1 metadata : name : full-access-to-pods namespace : dev rules : - apiGroups : - \"\" resources : - pods verbs : - '*'","title":"Role"},{"location":"kubernetes/rbac/#how-do-i-find-any-of-the-following-on-an-api-resource","text":"If the resource is Namespaced (scoped to a namespace) What API Group it's apart of What Verbs are allowed Resource names, shortnames, api groups, if the resource is namespaced (true/false), kind and allowed verbs are all available via the microk8s.kubectl api-resources -o wide command. Show me how to obtain API Resource details via kubectl $ microk8s.kubectl api-resources -o wide NAME SHORTNAMES APIGROUP NAMESPACED KIND VERBS bindings true Binding [create] componentstatuses cs false ComponentStatus [get list] configmaps cm true ConfigMap [create delete deletecollection get list patch update watch] endpoints ep true Endpoints [create delete deletecollection get list patch update watch] events ev true Event [create delete deletecollection get list patch update watch] limitranges limits true LimitRange [create delete deletecollection get list patch update watch] namespaces ns false Namespace [create delete get list patch update watch] nodes no false Node [create delete deletecollection get list patch update watch] persistentvolumeclaims pvc true PersistentVolumeClaim [create delete deletecollection get list patch update watch] persistentvolumes pv false PersistentVolume [create delete deletecollection get list patch update watch] pods po true Pod [create delete deletecollection get list patch update watch] podtemplates true PodTemplate [create delete deletecollection get list patch update watch] [snipped] horizontalpodautoscalers hpa autoscaling true HorizontalPodAutoscaler [create delete deletecollection get list patch update watch] cronjobs cj batch true CronJob [create delete deletecollection get list patch update watch] jobs batch true Job [create delete deletecollection get list patch update watch] certificatesigningrequests csr certificates.k8s.io false CertificateSigningRequest [create delete deletecollection get list patch update watch] leases coordination.k8s.io true Lease [create delete deletecollection get list patch update watch] endpointslices discovery.k8s.io true EndpointSlice [create delete deletecollection get list patch update watch] events ev events.k8s.io true Event [create delete deletecollection get list patch update watch] ingresses ing extensions true Ingress [create delete deletecollection get list patch update watch] ingresses ing networking.k8s.io true Ingress [create delete deletecollection get list patch update watch] networkpolicies netpol networking.k8s.io true NetworkPolicy [create delete deletecollection get list patch update watch] runtimeclasses node.k8s.io false RuntimeClass [create delete deletecollection get list patch update watch] poddisruptionbudgets pdb policy true PodDisruptionBudget [create delete deletecollection get list patch update watch] podsecuritypolicies psp policy false PodSecurityPolicy [create delete deletecollection get list patch update watch] clusterrolebindings rbac.authorization.k8s.io false ClusterRoleBinding [create delete deletecollection get list patch update watch] [snipped]","title":"How do I find any of the following on an API resource?"},{"location":"kubernetes/rbac/#now-lets-apply-the-role","text":"cat <<EOF | microk8s.kubectl apply -f - kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: full-access-to-pods namespace: dev rules: - apiGroups: - \"\" resources: - pods verbs: - '*' EOF","title":"Now Lets apply the Role"},{"location":"kubernetes/rbac/#rolebinding","text":"Now that we created a new namespace called dev , a service account called dev-pod-user and a role called full-access-to-pods lets associate them together with a RoleBinding. RoleBinding definition Let's define a RoleBinding called full-access-to-pods-role-binding which we will grant service account dev-pod-user access to the full-access-to-pods role. apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : full-access-to-pods-role-binding namespace : dev roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : full-access-to-pods subjects : - kind : ServiceAccount name : dev-pod-user See Binding Documentation for more information.","title":"RoleBinding"},{"location":"kubernetes/rbac/#now-lets-apply-the-rolebinding","text":"cat <<EOF | microk8s.kubectl apply -f - apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: full-access-to-pods-role-binding namespace: dev roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: full-access-to-pods subjects: - kind: ServiceAccount name: dev-pod-user EOF Tldr In order to create a service account you need to target an existing namespace or create a new one. A role can be created without a specific service account in mind but also need to target an existing namespace or create a new one. When creating a RoleBinding you will need to target a namespace, an existing role (roleRef) in that namespace and a user, group, or service account (subject).","title":"Now Lets apply the RoleBinding"},{"location":"kubernetes/rbac/#using-our-new-role","text":"TODO","title":"Using our new role"}]}